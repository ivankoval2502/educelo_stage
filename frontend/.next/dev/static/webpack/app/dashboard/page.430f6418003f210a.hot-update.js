"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/page",{

/***/ "(app-pages-browser)/./src/lib/api.ts":
/*!************************!*\
  !*** ./src/lib/api.ts ***!
  \************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createConversation: () => (/* binding */ createConversation),\n/* harmony export */   deleteConversation: () => (/* binding */ deleteConversation),\n/* harmony export */   generateConversationTitle: () => (/* binding */ generateConversationTitle),\n/* harmony export */   getConversation: () => (/* binding */ getConversation),\n/* harmony export */   getConversations: () => (/* binding */ getConversations),\n/* harmony export */   getCurrentUser: () => (/* binding */ getCurrentUser),\n/* harmony export */   loginUser: () => (/* binding */ loginUser),\n/* harmony export */   registerUser: () => (/* binding */ registerUser),\n/* harmony export */   sendMessage: () => (/* binding */ sendMessage),\n/* harmony export */   sendMessageStream: () => (/* binding */ sendMessageStream)\n/* harmony export */ });\nconst API_URL = \"http://localhost:8000\";\nasync function registerUser(data) {\n    const response = await fetch(`${API_URL}/api/v1/auth/register`, {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(data)\n    });\n    if (!response.ok) {\n        const error = await response.json();\n        throw new Error(error.detail || 'Registration failed');\n    }\n    return response.json();\n}\nasync function loginUser(data) {\n    const formData = new URLSearchParams();\n    formData.append('username', data.email);\n    formData.append('password', data.password);\n    const response = await fetch(`${API_URL}/api/v1/auth/login`, {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/x-www-form-urlencoded'\n        },\n        body: formData\n    });\n    if (!response.ok) {\n        const error = await response.json();\n        throw new Error(error.detail || 'Login failed');\n    }\n    return response.json();\n}\nasync function getCurrentUser() {\n    const token = localStorage.getItem('access_token');\n    if (!token) {\n        throw new Error('No access token found');\n    }\n    const response = await fetch(`${API_URL}/api/v1/auth/me`, {\n        method: 'GET',\n        headers: {\n            'Authorization': `Bearer ${token}`\n        }\n    });\n    if (!response.ok) {\n        const error = await response.json();\n        throw new Error(error.detail || 'Failed to get user');\n    }\n    return response.json();\n}\n// CHAT API\nasync function createConversation(data) {\n    const token = localStorage.getItem('access_token');\n    if (!token) {\n        throw new Error('No access token found');\n    }\n    const response = await fetch(`${API_URL}/api/v1/chat/conversations`, {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json',\n            'Authorization': `Bearer ${token}`\n        },\n        body: JSON.stringify(data)\n    });\n    if (!response.ok) {\n        const error = await response.json();\n        throw new Error(error.detail || 'Failed to create conversation');\n    }\n    return response.json();\n}\n// Получить список разговоров\nasync function getConversations() {\n    const token = localStorage.getItem('access_token');\n    if (!token) {\n        throw new Error('No access token found');\n    }\n    const response = await fetch(`${API_URL}/api/v1/chat/conversations`, {\n        method: 'GET',\n        headers: {\n            'Authorization': `Bearer ${token}`\n        }\n    });\n    if (!response.ok) {\n        const error = await response.json();\n        throw new Error(error.detail || 'Failed to get conversations');\n    }\n    return response.json();\n}\n// Получить конкретный разговор с сообщениями\nasync function getConversation(conversationId) {\n    const token = localStorage.getItem('access_token');\n    if (!token) {\n        throw new Error('No access token found');\n    }\n    const response = await fetch(`${API_URL}/api/v1/chat/conversations/${conversationId}`, {\n        method: 'GET',\n        headers: {\n            'Authorization': `Bearer ${token}`\n        }\n    });\n    if (!response.ok) {\n        const error = await response.json();\n        throw new Error(error.detail || 'Failed to get conversation');\n    }\n    return response.json();\n}\n// Отправить сообщение\nasync function sendMessage(conversationId, data) {\n    const token = localStorage.getItem('access_token');\n    if (!token) {\n        throw new Error('No access token found');\n    }\n    const response = await fetch(`${API_URL}/api/v1/chat/conversations/${conversationId}/messages`, {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json',\n            'Authorization': `Bearer ${token}`\n        },\n        body: JSON.stringify(data)\n    });\n    if (!response.ok) {\n        const error = await response.json();\n        throw new Error(error.detail || 'Failed to send message');\n    }\n    return response.json();\n}\nasync function sendMessageStream(conversationId, data, onChunk, onComplete, onError) {\n    const token = localStorage.getItem('access_token');\n    if (!token) {\n        throw new Error('No access token found');\n    }\n    const response = await fetch(`${API_URL}/api/v1/chat/conversations/${conversationId}/messages/stream`, {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json',\n            'Authorization': `Bearer ${token}`\n        },\n        body: JSON.stringify(data)\n    });\n    if (!response.ok) {\n        const error = await response.json();\n        throw new Error(error.detail || 'Failed to send message');\n    }\n    const reader = response.body?.getReader();\n    const decoder = new TextDecoder();\n    if (!reader) {\n        throw new Error('No response body');\n    }\n    let messageId = '';\n    try {\n        while(true){\n            const { done, value } = await reader.read();\n            if (done) break;\n            const chunk = decoder.decode(value);\n            const lines = chunk.split('\\n');\n            for (const line of lines){\n                if (line.startsWith('data: ')) {\n                    const data = JSON.parse(line.slice(6));\n                    if (data.type === 'start') {\n                        messageId = data.message_id;\n                    } else if (data.type === 'chunk') {\n                        onChunk(data.content);\n                    } else if (data.type === 'done') {\n                        onComplete(messageId);\n                    } else if (data.type === 'error') {\n                        onError(data.error);\n                    }\n                }\n            }\n        }\n    } catch (error) {\n        onError(error instanceof Error ? error.message : 'Unknown error');\n    }\n}\nasync function generateConversationTitle(conversationId) {\n    const token = localStorage.getItem('access_token');\n    if (!token) {\n        throw new Error('No access token found');\n    }\n    const response = await fetch(`${API_URL}/api/v1/chat/conversations/${conversationId}/generate-title`, {\n        method: 'POST',\n        headers: {\n            'Authorization': `Bearer ${token}`\n        }\n    });\n    if (!response.ok) {\n        const error = await response.json();\n        throw new Error(error.detail || 'Failed to generate title');\n    }\n    return response.json();\n}\n// Delete conversation\nasync function deleteConversation(conversationId) {\n    const token = localStorage.getItem('access_token');\n    if (!token) {\n        throw new Error('No access token found');\n    }\n    const response = await fetch(`${API_URL}/api/v1/chat/conversations/${conversationId}`, {\n        method: 'DELETE',\n        headers: {\n            'Authorization': `Bearer ${token}`\n        }\n    });\n    if (!response.ok) {\n        const error = await response.json();\n        throw new Error(error.detail || 'Failed to delete conversation');\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TUFBTSxJQUFJVCxNQUFNO0lBQ3BCO0lBRUEsTUFBTVYsV0FBVyxNQUFNQyxNQUNuQixHQUFHUCxRQUFRLDJCQUEyQixFQUFFK0IsZ0JBQWdCLEVBQ3hEO1FBQ0l2QixRQUFRO1FBQ1JDLFNBQVM7WUFDTCxpQkFBaUIsQ0FBQyxPQUFPLEVBQUVnQixPQUFPO1FBQ3RDO0lBQ0o7SUFHSixJQUFJLENBQUNuQixTQUFTTyxFQUFFLEVBQUU7UUFDZCxNQUFNQyxRQUFRLE1BQU1SLFNBQVNTLElBQUk7UUFDakMsTUFBTSxJQUFJQyxNQUFNRixNQUFNRyxNQUFNLElBQUk7SUFDcEM7QUFDSiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxnZ2RldmlhbnRcXERvY3VtZW50c1xcRWR1Y2Vsb1xcbXZwXFxmcm9udGVuZFxcc3JjXFxsaWJcXGFwaS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0xvZ2luRGF0YSwgUmVnaXN0ZXJEYXRhLCBVc2VyLCBBdXRoUmVzcG9uc2UsIENvbnZlcnNhdGlvbiwgQ29udmVyc2F0aW9uQ3JlYXRlLCBDb252ZXJzYXRpb25XaXRoTWVzc2FnZXMsIE1lc3NhZ2VDcmVhdGV9IGZyb20gXCJAL2xpYi90eXBlc1wiO1xyXG5pbXBvcnQge2Vycm9yfSBmcm9tIFwibmV4dC9kaXN0L2J1aWxkL291dHB1dC9sb2dcIjtcclxuaW1wb3J0IHtNZXNzYWdlfSBmcm9tIFwicG9zdGNzc1wiO1xyXG5cclxuY29uc3QgQVBJX1VSTCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkxcclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWdpc3RlclVzZXIoZGF0YTogUmVnaXN0ZXJEYXRhKTogUHJvbWlzZTxVc2VyPiB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9VUkx9L2FwaS92MS9hdXRoL3JlZ2lzdGVyYCwge1xyXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxyXG4gICAgfSlcclxuXHJcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSBhd2FpdCByZXNwb25zZS5qc29uKClcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IuZGV0YWlsIHx8ICdSZWdpc3RyYXRpb24gZmFpbGVkJylcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2dpblVzZXIoZGF0YTogTG9naW5EYXRhKTogUHJvbWlzZTxBdXRoUmVzcG9uc2U+IHtcclxuICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpXHJcbiAgICBmb3JtRGF0YS5hcHBlbmQoJ3VzZXJuYW1lJywgZGF0YS5lbWFpbClcclxuICAgIGZvcm1EYXRhLmFwcGVuZCgncGFzc3dvcmQnLCBkYXRhLnBhc3N3b3JkKVxyXG5cclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX1VSTH0vYXBpL3YxL2F1dGgvbG9naW5gLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBib2R5OiBmb3JtRGF0YSxcclxuICAgIH0pXHJcblxyXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgIGNvbnN0IGVycm9yID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yLmRldGFpbCB8fCAnTG9naW4gZmFpbGVkJylcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDdXJyZW50VXNlcigpOiBQcm9taXNlPFVzZXI+IHtcclxuICAgIGNvbnN0IHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2FjY2Vzc190b2tlbicpXHJcblxyXG4gICAgaWYgKCF0b2tlbikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvciAoJ05vIGFjY2VzcyB0b2tlbiBmb3VuZCcpXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfVVJMfS9hcGkvdjEvYXV0aC9tZWAsIHtcclxuICAgICAgICBtZXRob2Q6ICdHRVQnLFxyXG4gICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dG9rZW59YCxcclxuICAgICAgICB9LFxyXG4gICAgfSlcclxuXHJcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSBhd2FpdCByZXNwb25zZS5qc29uKClcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IuZGV0YWlsIHx8ICdGYWlsZWQgdG8gZ2V0IHVzZXInKVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXNwb25zZS5qc29uKClcclxufVxyXG5cclxuLy8gQ0hBVCBBUElcclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVDb252ZXJzYXRpb24oZGF0YTogQ29udmVyc2F0aW9uQ3JlYXRlKTogUHJvbWlzZTxDb252ZXJzYXRpb24+IHtcclxuICAgIGNvbnN0IHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2FjY2Vzc190b2tlbicpXHJcblxyXG4gICAgaWYgKCF0b2tlbikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYWNjZXNzIHRva2VuIGZvdW5kJylcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9VUkx9L2FwaS92MS9jaGF0L2NvbnZlcnNhdGlvbnNgLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0b2tlbn1gLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXHJcbiAgICB9KVxyXG5cclxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgICBjb25zdCBlcnJvciA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvci5kZXRhaWwgfHwgJ0ZhaWxlZCB0byBjcmVhdGUgY29udmVyc2F0aW9uJylcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXHJcbn1cclxuXHJcbi8vINCf0L7Qu9GD0YfQuNGC0Ywg0YHQv9C40YHQvtC6INGA0LDQt9Cz0L7QstC+0YDQvtCyXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDb252ZXJzYXRpb25zKCk6IFByb21pc2U8Q29udmVyc2F0aW9uW10+IHtcclxuICAgIGNvbnN0IHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2FjY2Vzc190b2tlbicpXHJcblxyXG4gICAgaWYgKCF0b2tlbikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYWNjZXNzIHRva2VuIGZvdW5kJylcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9VUkx9L2FwaS92MS9jaGF0L2NvbnZlcnNhdGlvbnNgLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcclxuICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3Rva2VufWAsXHJcbiAgICAgICAgfSxcclxuICAgIH0pXHJcblxyXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgIGNvbnN0IGVycm9yID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yLmRldGFpbCB8fCAnRmFpbGVkIHRvIGdldCBjb252ZXJzYXRpb25zJylcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXHJcbn1cclxuXHJcbi8vINCf0L7Qu9GD0YfQuNGC0Ywg0LrQvtC90LrRgNC10YLQvdGL0Lkg0YDQsNC30LPQvtCy0L7RgCDRgSDRgdC+0L7QsdGJ0LXQvdC40Y/QvNC4XHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDb252ZXJzYXRpb24oY29udmVyc2F0aW9uSWQ6IHN0cmluZyk6IFByb21pc2U8Q29udmVyc2F0aW9uV2l0aE1lc3NhZ2VzPiB7XHJcbiAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdhY2Nlc3NfdG9rZW4nKVxyXG5cclxuICAgIGlmICghdG9rZW4pIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFjY2VzcyB0b2tlbiBmb3VuZCcpXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfVVJMfS9hcGkvdjEvY2hhdC9jb252ZXJzYXRpb25zLyR7Y29udmVyc2F0aW9uSWR9YCwge1xyXG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXHJcbiAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0b2tlbn1gLFxyXG4gICAgICAgIH0sXHJcbiAgICB9KVxyXG5cclxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgICBjb25zdCBlcnJvciA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvci5kZXRhaWwgfHwgJ0ZhaWxlZCB0byBnZXQgY29udmVyc2F0aW9uJylcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXHJcbn1cclxuXHJcbi8vINCe0YLQv9GA0LDQstC40YLRjCDRgdC+0L7QsdGJ0LXQvdC40LVcclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNlbmRNZXNzYWdlKFxyXG4gICAgY29udmVyc2F0aW9uSWQ6IHN0cmluZyxcclxuICAgIGRhdGE6IE1lc3NhZ2VDcmVhdGVcclxuKTogUHJvbWlzZTxNZXNzYWdlPiB7XHJcbiAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdhY2Nlc3NfdG9rZW4nKVxyXG5cclxuICAgIGlmICghdG9rZW4pIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFjY2VzcyB0b2tlbiBmb3VuZCcpXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcclxuICAgICAgICBgJHtBUElfVVJMfS9hcGkvdjEvY2hhdC9jb252ZXJzYXRpb25zLyR7Y29udmVyc2F0aW9uSWR9L21lc3NhZ2VzYCxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dG9rZW59YCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXHJcbiAgICAgICAgfVxyXG4gICAgKVxyXG5cclxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgICBjb25zdCBlcnJvciA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvci5kZXRhaWwgfHwgJ0ZhaWxlZCB0byBzZW5kIG1lc3NhZ2UnKVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXNwb25zZS5qc29uKCkgYXMgUHJvbWlzZTxNZXNzYWdlPlxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2VuZE1lc3NhZ2VTdHJlYW0oXHJcbiAgICBjb252ZXJzYXRpb25JZDogc3RyaW5nLFxyXG4gICAgZGF0YTogTWVzc2FnZUNyZWF0ZSxcclxuICAgIG9uQ2h1bms6IChjaHVuazogc3RyaW5nKSA9PiB2b2lkLFxyXG4gICAgb25Db21wbGV0ZTogKG1lc3NhZ2VJZDogc3RyaW5nKSA9PiB2b2lkLFxyXG4gICAgb25FcnJvcjogKGVycm9yOiBzdHJpbmcpID0+IHZvaWRcclxuKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdhY2Nlc3NfdG9rZW4nKVxyXG5cclxuICAgIGlmICghdG9rZW4pIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFjY2VzcyB0b2tlbiBmb3VuZCcpXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcclxuICAgICAgICBgJHtBUElfVVJMfS9hcGkvdjEvY2hhdC9jb252ZXJzYXRpb25zLyR7Y29udmVyc2F0aW9uSWR9L21lc3NhZ2VzL3N0cmVhbWAsXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3Rva2VufWAsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxyXG4gICAgICAgIH1cclxuICAgIClcclxuXHJcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSBhd2FpdCByZXNwb25zZS5qc29uKClcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IuZGV0YWlsIHx8ICdGYWlsZWQgdG8gc2VuZCBtZXNzYWdlJylcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5Py5nZXRSZWFkZXIoKVxyXG4gICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpXHJcblxyXG4gICAgaWYgKCFyZWFkZXIpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHJlc3BvbnNlIGJvZHknKVxyXG4gICAgfVxyXG5cclxuICAgIGxldCBtZXNzYWdlSWQgPSAnJ1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKVxyXG5cclxuICAgICAgICAgICAgaWYgKGRvbmUpIGJyZWFrXHJcblxyXG4gICAgICAgICAgICBjb25zdCBjaHVuayA9IGRlY29kZXIuZGVjb2RlKHZhbHVlKVxyXG4gICAgICAgICAgICBjb25zdCBsaW5lcyA9IGNodW5rLnNwbGl0KCdcXG4nKVxyXG5cclxuICAgICAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGluZS5zdGFydHNXaXRoKCdkYXRhOiAnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGxpbmUuc2xpY2UoNikpXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLnR5cGUgPT09ICdzdGFydCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZUlkID0gZGF0YS5tZXNzYWdlX2lkXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICdjaHVuaycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DaHVuayhkYXRhLmNvbnRlbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICdkb25lJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNvbXBsZXRlKG1lc3NhZ2VJZClcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gJ2Vycm9yJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yKGRhdGEuZXJyb3IpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBvbkVycm9yKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InKVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVDb252ZXJzYXRpb25UaXRsZShcclxuICAgIGNvbnZlcnNhdGlvbklkOiBzdHJpbmdcclxuKTogUHJvbWlzZTxDb252ZXJzYXRpb24+IHtcclxuICAgIGNvbnN0IHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2FjY2Vzc190b2tlbicpXHJcblxyXG4gICAgaWYgKCF0b2tlbikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYWNjZXNzIHRva2VuIGZvdW5kJylcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFxyXG4gICAgICAgIGAke0FQSV9VUkx9L2FwaS92MS9jaGF0L2NvbnZlcnNhdGlvbnMvJHtjb252ZXJzYXRpb25JZH0vZ2VuZXJhdGUtdGl0bGVgLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3Rva2VufWAsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfVxyXG4gICAgKVxyXG5cclxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgICBjb25zdCBlcnJvciA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvci5kZXRhaWwgfHwgJ0ZhaWxlZCB0byBnZW5lcmF0ZSB0aXRsZScpXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxyXG59XHJcblxyXG4vLyBEZWxldGUgY29udmVyc2F0aW9uXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWxldGVDb252ZXJzYXRpb24oY29udmVyc2F0aW9uSWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnYWNjZXNzX3Rva2VuJylcclxuXHJcbiAgICBpZiAoIXRva2VuKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhY2Nlc3MgdG9rZW4gZm91bmQnKVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXHJcbiAgICAgICAgYCR7QVBJX1VSTH0vYXBpL3YxL2NoYXQvY29udmVyc2F0aW9ucy8ke2NvbnZlcnNhdGlvbklkfWAsXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxyXG4gICAgICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0b2tlbn1gLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH1cclxuICAgIClcclxuXHJcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSBhd2FpdCByZXNwb25zZS5qc29uKClcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IuZGV0YWlsIHx8ICdGYWlsZWQgdG8gZGVsZXRlIGNvbnZlcnNhdGlvbicpXHJcbiAgICB9XHJcbn0iXSwibmFtZXMiOlsiQVBJX1VSTCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfVVJMIiwicmVnaXN0ZXJVc2VyIiwiZGF0YSIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJvayIsImVycm9yIiwianNvbiIsIkVycm9yIiwiZGV0YWlsIiwibG9naW5Vc2VyIiwiZm9ybURhdGEiLCJVUkxTZWFyY2hQYXJhbXMiLCJhcHBlbmQiLCJlbWFpbCIsInBhc3N3b3JkIiwiZ2V0Q3VycmVudFVzZXIiLCJ0b2tlbiIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJjcmVhdGVDb252ZXJzYXRpb24iLCJnZXRDb252ZXJzYXRpb25zIiwiZ2V0Q29udmVyc2F0aW9uIiwiY29udmVyc2F0aW9uSWQiLCJzZW5kTWVzc2FnZSIsInNlbmRNZXNzYWdlU3RyZWFtIiwib25DaHVuayIsIm9uQ29tcGxldGUiLCJvbkVycm9yIiwicmVhZGVyIiwiZ2V0UmVhZGVyIiwiZGVjb2RlciIsIlRleHREZWNvZGVyIiwibWVzc2FnZUlkIiwiZG9uZSIsInZhbHVlIiwicmVhZCIsImNodW5rIiwiZGVjb2RlIiwibGluZXMiLCJzcGxpdCIsImxpbmUiLCJzdGFydHNXaXRoIiwicGFyc2UiLCJzbGljZSIsInR5cGUiLCJtZXNzYWdlX2lkIiwiY29udGVudCIsIm1lc3NhZ2UiLCJnZW5lcmF0ZUNvbnZlcnNhdGlvblRpdGxlIiwiZGVsZXRlQ29udmVyc2F0aW9uIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/api.ts\n"));

/***/ })

});