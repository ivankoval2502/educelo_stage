"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/auth/page",{

/***/ "(app-pages-browser)/./src/lib/api.ts":
/*!************************!*\
  !*** ./src/lib/api.ts ***!
  \************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   changePassword: () => (/* binding */ changePassword),\n/* harmony export */   createConversation: () => (/* binding */ createConversation),\n/* harmony export */   deleteConversation: () => (/* binding */ deleteConversation),\n/* harmony export */   deleteMessage: () => (/* binding */ deleteMessage),\n/* harmony export */   generateConversationTitle: () => (/* binding */ generateConversationTitle),\n/* harmony export */   getConversation: () => (/* binding */ getConversation),\n/* harmony export */   getConversations: () => (/* binding */ getConversations),\n/* harmony export */   getCurrentUser: () => (/* binding */ getCurrentUser),\n/* harmony export */   getProgressActivity: () => (/* binding */ getProgressActivity),\n/* harmony export */   getProgressStats: () => (/* binding */ getProgressStats),\n/* harmony export */   loginUser: () => (/* binding */ loginUser),\n/* harmony export */   registerUser: () => (/* binding */ registerUser),\n/* harmony export */   sendMessage: () => (/* binding */ sendMessage),\n/* harmony export */   sendMessageStream: () => (/* binding */ sendMessageStream),\n/* harmony export */   updateUserProfile: () => (/* binding */ updateUserProfile),\n/* harmony export */   updateWeeklyGoal: () => (/* binding */ updateWeeklyGoal)\n/* harmony export */ });\nconst API_URL = \"http://localhost:8000\";\nasync function registerUser(data) {\n    const response = await fetch(`${API_URL}/api/v1/auth/register`, {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(data)\n    });\n    if (!response.ok) {\n        const error = await response.json();\n        throw new Error(error.detail || 'Registration failed');\n    }\n    return response.json();\n}\nasync function loginUser(data) {\n    const formData = new URLSearchParams();\n    formData.append('username', data.email);\n    formData.append('password', data.password);\n    const response = await fetch(`${API_URL}/api/v1/auth/login`, {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/x-www-form-urlencoded'\n        },\n        body: formData\n    });\n    if (!response.ok) {\n        const error = await response.json();\n        throw new Error(error.detail || 'Login failed');\n    }\n    return response.json();\n}\nasync function getCurrentUser() {\n    const token = localStorage.getItem('access_token');\n    if (!token) {\n        throw new Error('No access token found');\n    }\n    const response = await fetch(`${API_URL}/api/v1/auth/me`, {\n        method: 'GET',\n        headers: {\n            'Authorization': `Bearer ${token}`\n        }\n    });\n    if (!response.ok) {\n        const error = await response.json();\n        throw new Error(error.detail || 'Failed to get user');\n    }\n    return response.json();\n}\n// CHAT API\nasync function createConversation(data) {\n    const token = localStorage.getItem('access_token');\n    if (!token) {\n        throw new Error('No access token found');\n    }\n    const response = await fetch(`${API_URL}/api/v1/chat/conversations`, {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json',\n            'Authorization': `Bearer ${token}`\n        },\n        body: JSON.stringify(data)\n    });\n    if (!response.ok) {\n        const error = await response.json();\n        throw new Error(error.detail || 'Failed to create conversation');\n    }\n    return response.json();\n}\n// Получить список разговоров\nasync function getConversations() {\n    const token = localStorage.getItem('access_token');\n    if (!token) {\n        throw new Error('No access token found');\n    }\n    const response = await fetch(`${API_URL}/api/v1/chat/conversations`, {\n        method: 'GET',\n        headers: {\n            'Authorization': `Bearer ${token}`\n        }\n    });\n    if (!response.ok) {\n        const error = await response.json();\n        throw new Error(error.detail || 'Failed to get conversations');\n    }\n    return response.json();\n}\n// Получить конкретный разговор с сообщениями\nasync function getConversation(conversationId) {\n    const token = localStorage.getItem('access_token');\n    if (!token) {\n        throw new Error('No access token found');\n    }\n    const response = await fetch(`${API_URL}/api/v1/chat/conversations/${conversationId}`, {\n        method: 'GET',\n        headers: {\n            'Authorization': `Bearer ${token}`\n        }\n    });\n    if (!response.ok) {\n        const error = await response.json();\n        throw new Error(error.detail || 'Failed to get conversation');\n    }\n    return response.json();\n}\n// Отправить сообщение\nasync function sendMessage(conversationId, data) {\n    const token = localStorage.getItem('access_token');\n    if (!token) {\n        throw new Error('No access token found');\n    }\n    const response = await fetch(`${API_URL}/api/v1/chat/conversations/${conversationId}/messages`, {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json',\n            'Authorization': `Bearer ${token}`\n        },\n        body: JSON.stringify(data)\n    });\n    if (!response.ok) {\n        const error = await response.json();\n        throw new Error(error.detail || 'Failed to send message');\n    }\n    return response.json();\n}\nasync function sendMessageStream(conversationId, data, onChunk, onComplete, onError, signal) {\n    const token = localStorage.getItem('access_token');\n    if (!token) {\n        throw new Error('No access token found');\n    }\n    try {\n        const response = await fetch(`${API_URL}/api/v1/chat/conversations/${conversationId}/messages/stream`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'Authorization': `Bearer ${token}`\n            },\n            body: JSON.stringify(data),\n            signal\n        });\n        if (!response.ok) {\n            const error = await response.json();\n            throw new Error(error.detail || 'Failed to send message');\n        }\n        const reader = response.body?.getReader();\n        const decoder = new TextDecoder();\n        if (!reader) {\n            throw new Error('No reader available');\n        }\n        let messageId = '';\n        while(true){\n            const { done, value } = await reader.read();\n            if (done) break;\n            const chunk = decoder.decode(value, {\n                stream: true\n            });\n            const lines = chunk.split('\\n');\n            for (const line of lines){\n                if (line.startsWith('data: ')) {\n                    const data = line.slice(6);\n                    if (data === '[DONE]') {\n                        onComplete(messageId);\n                        return;\n                    }\n                    try {\n                        const parsed = JSON.parse(data);\n                        if (parsed.message_id) {\n                            messageId = parsed.message_id;\n                        }\n                        if (parsed.content) {\n                            onChunk(parsed.content);\n                        }\n                    } catch (e) {\n                        console.error('Failed to parse SSE data:', e);\n                    }\n                }\n            }\n        }\n    } catch (error) {\n        if (error instanceof Error && error.name === 'AbortError') {\n            console.log('Generation stopped by user');\n            throw error;\n        }\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n        onError(errorMessage);\n        throw error;\n    }\n}\nasync function generateConversationTitle(conversationId) {\n    const token = localStorage.getItem('access_token');\n    if (!token) {\n        throw new Error('No access token found');\n    }\n    const response = await fetch(`${API_URL}/api/v1/chat/conversations/${conversationId}/generate-title`, {\n        method: 'POST',\n        headers: {\n            'Authorization': `Bearer ${token}`\n        }\n    });\n    if (!response.ok) {\n        const error = await response.json();\n        throw new Error(error.detail || 'Failed to generate title');\n    }\n    return response.json();\n}\n// Delete conversation\nasync function deleteConversation(conversationId) {\n    const token = localStorage.getItem('access_token');\n    if (!token) {\n        throw new Error('No access token found');\n    }\n    const response = await fetch(`${API_URL}/api/v1/chat/conversations/${conversationId}`, {\n        method: 'DELETE',\n        headers: {\n            'Authorization': `Bearer ${token}`\n        }\n    });\n    if (!response.ok) {\n        const error = await response.json();\n        throw new Error(error.detail || 'Failed to delete conversation');\n    }\n}\n// Delete message\nasync function deleteMessage(conversationId, messageId) {\n    const token = localStorage.getItem('access_token');\n    if (!token) {\n        throw new Error('No access token found');\n    }\n    const response = await fetch(`${API_URL}/api/v1/chat/conversations/${conversationId}/messages/${messageId}`, {\n        method: 'DELETE',\n        headers: {\n            'Authorization': `Bearer ${token}`\n        }\n    });\n    if (!response.ok) {\n        const error = await response.json();\n        throw new Error(error.detail || 'Failed to delete message');\n    }\n}\n//Progress API\nasync function getProgressStats() {\n    const response = await fetch(`${API_URL}/api/v1/progress/stats`, {\n        headers: {\n            'Authorization': `Bearer ${localStorage.getItem('access_token')}`\n        }\n    });\n    if (!response.ok) {\n        throw new Error('Failed to fetch progress stats');\n    }\n    return response.json();\n}\nasync function getProgressActivity() {\n    const response = await fetch(`${API_URL}/api/v1/progress/activity`, {\n        headers: {\n            'Authorization': `Bearer ${localStorage.getItem('access_token')}`\n        }\n    });\n    if (!response.ok) {\n        throw new Error('Failed to fetch activity data');\n    }\n    return response.json();\n}\n// Update user's data\nasync function updateUserProfile(data) {\n    const token = localStorage.getItem('access_token');\n    if (!token) {\n        throw new Error('No access token found');\n    }\n    const response = await fetch(`${API_URL}/api/v1/auth/me`, {\n        method: 'PATCH',\n        headers: {\n            'Content-Type': 'application/json',\n            'Authorization': `Bearer ${token}`\n        },\n        body: JSON.stringify(data)\n    });\n    if (!response.ok) {\n        const error = await response.json();\n        throw new Error(error.detail || 'Failed to update profile');\n    }\n    return response.json();\n}\nasync function changePassword(currentPassword, newPassword) {\n    const token = localStorage.getItem('access_token');\n    if (!token) {\n        throw new Error('No access token found');\n    }\n    const response = await fetch(`${API_URL}/api/v1/auth/change-password`, {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json',\n            'Authorization': `Bearer ${token}`\n        },\n        body: JSON.stringify({\n            current_password: currentPassword,\n            new_password: newPassword\n        })\n    });\n    if (!response.ok) {\n        const error = await response.json();\n        throw new Error(error.detail || 'Failed to change password');\n    }\n    return response.json();\n}\nasync function updateWeeklyGoal(weeklyGoalHours) {\n    const token = localStorage.getItem('access_token');\n    if (!token) {\n        throw new Error('No access token found');\n    }\n    const response = await fetch(`${API_URL}/api/v1/auth/goal`, {\n        method: 'PATCH',\n        headers: {\n            'Content-Type': 'application/json',\n            'Authorization': `Bearer ${token}`\n        },\n        body: JSON.stringify({\n            weekly_goal_hours: weeklyGoalHours\n        })\n    });\n    if (!response.ok) {\n        const error = await response.json();\n        throw new Error(error.detail || 'Failed to update weekly goal');\n    }\n    return response.json();\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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ZnJvbnRlbmRcXHNyY1xcbGliXFxhcGkudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtMb2dpbkRhdGEsIFJlZ2lzdGVyRGF0YSwgVXNlciwgQXV0aFJlc3BvbnNlLCBDb252ZXJzYXRpb24sIENvbnZlcnNhdGlvbkNyZWF0ZSwgQ29udmVyc2F0aW9uV2l0aE1lc3NhZ2VzLCBNZXNzYWdlQ3JlYXRlfSBmcm9tIFwiQC9saWIvdHlwZXNcIjtcclxuaW1wb3J0IHtlcnJvcn0gZnJvbSBcIm5leHQvZGlzdC9idWlsZC9vdXRwdXQvbG9nXCI7XHJcbmltcG9ydCB7TWVzc2FnZX0gZnJvbSBcInBvc3Rjc3NcIjtcclxuXHJcbmNvbnN0IEFQSV9VUkwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMXHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVnaXN0ZXJVc2VyKGRhdGE6IFJlZ2lzdGVyRGF0YSk6IFByb21pc2U8VXNlcj4ge1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfVVJMfS9hcGkvdjEvYXV0aC9yZWdpc3RlcmAsIHtcclxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcclxuICAgIH0pXHJcblxyXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgIGNvbnN0IGVycm9yID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yLmRldGFpbCB8fCAnUmVnaXN0cmF0aW9uIGZhaWxlZCcpXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbG9naW5Vc2VyKGRhdGE6IExvZ2luRGF0YSk6IFByb21pc2U8QXV0aFJlc3BvbnNlPiB7XHJcbiAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKVxyXG4gICAgZm9ybURhdGEuYXBwZW5kKCd1c2VybmFtZScsIGRhdGEuZW1haWwpXHJcbiAgICBmb3JtRGF0YS5hcHBlbmQoJ3Bhc3N3b3JkJywgZGF0YS5wYXNzd29yZClcclxuXHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9VUkx9L2FwaS92MS9hdXRoL2xvZ2luYCwge1xyXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYm9keTogZm9ybURhdGEsXHJcbiAgICB9KVxyXG5cclxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgICBjb25zdCBlcnJvciA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvci5kZXRhaWwgfHwgJ0xvZ2luIGZhaWxlZCcpXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q3VycmVudFVzZXIoKTogUHJvbWlzZTxVc2VyPiB7XHJcbiAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdhY2Nlc3NfdG9rZW4nKVxyXG5cclxuICAgIGlmICghdG9rZW4pIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IgKCdObyBhY2Nlc3MgdG9rZW4gZm91bmQnKVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX1VSTH0vYXBpL3YxL2F1dGgvbWVgLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcclxuICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3Rva2VufWAsXHJcbiAgICAgICAgfSxcclxuICAgIH0pXHJcblxyXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgIGNvbnN0IGVycm9yID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yLmRldGFpbCB8fCAnRmFpbGVkIHRvIGdldCB1c2VyJylcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXHJcbn1cclxuXHJcbi8vIENIQVQgQVBJXHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlQ29udmVyc2F0aW9uKGRhdGE6IENvbnZlcnNhdGlvbkNyZWF0ZSk6IFByb21pc2U8Q29udmVyc2F0aW9uPiB7XHJcbiAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdhY2Nlc3NfdG9rZW4nKVxyXG5cclxuICAgIGlmICghdG9rZW4pIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFjY2VzcyB0b2tlbiBmb3VuZCcpXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfVVJMfS9hcGkvdjEvY2hhdC9jb252ZXJzYXRpb25zYCwge1xyXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dG9rZW59YCxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxyXG4gICAgfSlcclxuXHJcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSBhd2FpdCByZXNwb25zZS5qc29uKClcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IuZGV0YWlsIHx8ICdGYWlsZWQgdG8gY3JlYXRlIGNvbnZlcnNhdGlvbicpXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxyXG59XHJcblxyXG4vLyDQn9C+0LvRg9GH0LjRgtGMINGB0L/QuNGB0L7QuiDRgNCw0LfQs9C+0LLQvtGA0L7QslxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q29udmVyc2F0aW9ucygpOiBQcm9taXNlPENvbnZlcnNhdGlvbltdPiB7XHJcbiAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdhY2Nlc3NfdG9rZW4nKVxyXG5cclxuICAgIGlmICghdG9rZW4pIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFjY2VzcyB0b2tlbiBmb3VuZCcpXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfVVJMfS9hcGkvdjEvY2hhdC9jb252ZXJzYXRpb25zYCwge1xyXG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXHJcbiAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0b2tlbn1gLFxyXG4gICAgICAgIH0sXHJcbiAgICB9KVxyXG5cclxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgICBjb25zdCBlcnJvciA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvci5kZXRhaWwgfHwgJ0ZhaWxlZCB0byBnZXQgY29udmVyc2F0aW9ucycpXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxyXG59XHJcblxyXG4vLyDQn9C+0LvRg9GH0LjRgtGMINC60L7QvdC60YDQtdGC0L3Ri9C5INGA0LDQt9Cz0L7QstC+0YAg0YEg0YHQvtC+0LHRidC10L3QuNGP0LzQuFxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q29udmVyc2F0aW9uKGNvbnZlcnNhdGlvbklkOiBzdHJpbmcpOiBQcm9taXNlPENvbnZlcnNhdGlvbldpdGhNZXNzYWdlcz4ge1xyXG4gICAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnYWNjZXNzX3Rva2VuJylcclxuXHJcbiAgICBpZiAoIXRva2VuKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhY2Nlc3MgdG9rZW4gZm91bmQnKVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX1VSTH0vYXBpL3YxL2NoYXQvY29udmVyc2F0aW9ucy8ke2NvbnZlcnNhdGlvbklkfWAsIHtcclxuICAgICAgICBtZXRob2Q6ICdHRVQnLFxyXG4gICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dG9rZW59YCxcclxuICAgICAgICB9LFxyXG4gICAgfSlcclxuXHJcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSBhd2FpdCByZXNwb25zZS5qc29uKClcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IuZGV0YWlsIHx8ICdGYWlsZWQgdG8gZ2V0IGNvbnZlcnNhdGlvbicpXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxyXG59XHJcblxyXG4vLyDQntGC0L/RgNCw0LLQuNGC0Ywg0YHQvtC+0LHRidC10L3QuNC1XHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZW5kTWVzc2FnZShcclxuICAgIGNvbnZlcnNhdGlvbklkOiBzdHJpbmcsXHJcbiAgICBkYXRhOiBNZXNzYWdlQ3JlYXRlXHJcbik6IFByb21pc2U8TWVzc2FnZT4ge1xyXG4gICAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnYWNjZXNzX3Rva2VuJylcclxuXHJcbiAgICBpZiAoIXRva2VuKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhY2Nlc3MgdG9rZW4gZm91bmQnKVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXHJcbiAgICAgICAgYCR7QVBJX1VSTH0vYXBpL3YxL2NoYXQvY29udmVyc2F0aW9ucy8ke2NvbnZlcnNhdGlvbklkfS9tZXNzYWdlc2AsXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3Rva2VufWAsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxyXG4gICAgICAgIH1cclxuICAgIClcclxuXHJcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSBhd2FpdCByZXNwb25zZS5qc29uKClcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IuZGV0YWlsIHx8ICdGYWlsZWQgdG8gc2VuZCBtZXNzYWdlJylcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpIGFzIFByb21pc2U8TWVzc2FnZT5cclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNlbmRNZXNzYWdlU3RyZWFtKFxyXG4gICAgY29udmVyc2F0aW9uSWQ6IHN0cmluZyxcclxuICAgIGRhdGE6IE1lc3NhZ2VDcmVhdGUsXHJcbiAgICBvbkNodW5rOiAoY2h1bms6IHN0cmluZykgPT4gdm9pZCxcclxuICAgIG9uQ29tcGxldGU6IChtZXNzYWdlSWQ6IHN0cmluZykgPT4gdm9pZCxcclxuICAgIG9uRXJyb3I6IChlcnJvcjogc3RyaW5nKSA9PiB2b2lkLFxyXG4gICAgc2lnbmFsPzogQWJvcnRTaWduYWxcclxuKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdhY2Nlc3NfdG9rZW4nKVxyXG5cclxuICAgIGlmICghdG9rZW4pIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFjY2VzcyB0b2tlbiBmb3VuZCcpXHJcbiAgICB9XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFxyXG4gICAgICAgICAgICBgJHtBUElfVVJMfS9hcGkvdjEvY2hhdC9jb252ZXJzYXRpb25zLyR7Y29udmVyc2F0aW9uSWR9L21lc3NhZ2VzL3N0cmVhbWAsXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgICAgICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dG9rZW59YCxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcclxuICAgICAgICAgICAgICAgIHNpZ25hbCxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIClcclxuXHJcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IuZGV0YWlsIHx8ICdGYWlsZWQgdG8gc2VuZCBtZXNzYWdlJylcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHk/LmdldFJlYWRlcigpXHJcbiAgICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpXHJcblxyXG4gICAgICAgIGlmICghcmVhZGVyKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcmVhZGVyIGF2YWlsYWJsZScpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgbWVzc2FnZUlkID0gJydcclxuXHJcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKVxyXG5cclxuICAgICAgICAgICAgaWYgKGRvbmUpIGJyZWFrXHJcblxyXG4gICAgICAgICAgICBjb25zdCBjaHVuayA9IGRlY29kZXIuZGVjb2RlKHZhbHVlLCB7IHN0cmVhbTogdHJ1ZSB9KVxyXG4gICAgICAgICAgICBjb25zdCBsaW5lcyA9IGNodW5rLnNwbGl0KCdcXG4nKVxyXG5cclxuICAgICAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGluZS5zdGFydHNXaXRoKCdkYXRhOiAnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBsaW5lLnNsaWNlKDYpXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhID09PSAnW0RPTkVdJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNvbXBsZXRlKG1lc3NhZ2VJZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKGRhdGEpXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VkLm1lc3NhZ2VfaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VJZCA9IHBhcnNlZC5tZXNzYWdlX2lkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZWQuY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaHVuayhwYXJzZWQuY29udGVudClcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHBhcnNlIFNTRSBkYXRhOicsIGUpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ0dlbmVyYXRpb24gc3RvcHBlZCBieSB1c2VyJylcclxuICAgICAgICAgICAgdGhyb3cgZXJyb3JcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InXHJcbiAgICAgICAgb25FcnJvcihlcnJvck1lc3NhZ2UpXHJcbiAgICAgICAgdGhyb3cgZXJyb3JcclxuICAgIH1cclxufVxyXG5cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZUNvbnZlcnNhdGlvblRpdGxlKFxyXG4gICAgY29udmVyc2F0aW9uSWQ6IHN0cmluZ1xyXG4pOiBQcm9taXNlPENvbnZlcnNhdGlvbj4ge1xyXG4gICAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnYWNjZXNzX3Rva2VuJylcclxuXHJcbiAgICBpZiAoIXRva2VuKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhY2Nlc3MgdG9rZW4gZm91bmQnKVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXHJcbiAgICAgICAgYCR7QVBJX1VSTH0vYXBpL3YxL2NoYXQvY29udmVyc2F0aW9ucy8ke2NvbnZlcnNhdGlvbklkfS9nZW5lcmF0ZS10aXRsZWAsXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dG9rZW59YCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9XHJcbiAgICApXHJcblxyXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgIGNvbnN0IGVycm9yID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yLmRldGFpbCB8fCAnRmFpbGVkIHRvIGdlbmVyYXRlIHRpdGxlJylcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXHJcbn1cclxuXHJcbi8vIERlbGV0ZSBjb252ZXJzYXRpb25cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUNvbnZlcnNhdGlvbihjb252ZXJzYXRpb25JZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdhY2Nlc3NfdG9rZW4nKVxyXG5cclxuICAgIGlmICghdG9rZW4pIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFjY2VzcyB0b2tlbiBmb3VuZCcpXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcclxuICAgICAgICBgJHtBUElfVVJMfS9hcGkvdjEvY2hhdC9jb252ZXJzYXRpb25zLyR7Y29udmVyc2F0aW9uSWR9YCxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXHJcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3Rva2VufWAsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfVxyXG4gICAgKVxyXG5cclxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgICBjb25zdCBlcnJvciA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvci5kZXRhaWwgfHwgJ0ZhaWxlZCB0byBkZWxldGUgY29udmVyc2F0aW9uJylcclxuICAgIH1cclxufVxyXG5cclxuLy8gRGVsZXRlIG1lc3NhZ2VcclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZU1lc3NhZ2UoXHJcbiAgICBjb252ZXJzYXRpb25JZDogc3RyaW5nLFxyXG4gICAgbWVzc2FnZUlkOiBzdHJpbmdcclxuKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdhY2Nlc3NfdG9rZW4nKVxyXG5cclxuICAgIGlmICghdG9rZW4pIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFjY2VzcyB0b2tlbiBmb3VuZCcpXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcclxuICAgICAgICBgJHtBUElfVVJMfS9hcGkvdjEvY2hhdC9jb252ZXJzYXRpb25zLyR7Y29udmVyc2F0aW9uSWR9L21lc3NhZ2VzLyR7bWVzc2FnZUlkfWAsXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxyXG4gICAgICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0b2tlbn1gLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH1cclxuICAgIClcclxuXHJcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSBhd2FpdCByZXNwb25zZS5qc29uKClcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IuZGV0YWlsIHx8ICdGYWlsZWQgdG8gZGVsZXRlIG1lc3NhZ2UnKVxyXG4gICAgfVxyXG59XHJcblxyXG4vL1Byb2dyZXNzIEFQSVxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UHJvZ3Jlc3NTdGF0cygpIHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX1VSTH0vYXBpL3YxL3Byb2dyZXNzL3N0YXRzYCwge1xyXG4gICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7bG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2FjY2Vzc190b2tlbicpfWBcclxuICAgICAgICB9XHJcbiAgICB9KVxyXG5cclxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBwcm9ncmVzcyBzdGF0cycpXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UHJvZ3Jlc3NBY3Rpdml0eSgpIHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX1VSTH0vYXBpL3YxL3Byb2dyZXNzL2FjdGl2aXR5YCwge1xyXG4gICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7bG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2FjY2Vzc190b2tlbicpfWBcclxuICAgICAgICB9XHJcbiAgICB9KVxyXG5cclxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBhY3Rpdml0eSBkYXRhJylcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXHJcbn1cclxuXHJcbi8vIFVwZGF0ZSB1c2VyJ3MgZGF0YVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVVzZXJQcm9maWxlKGRhdGE6IHt1c2VybmFtZT86IHN0cmluZywgZW1haWw/OiBzdHJpbmd9KTogUHJvbWlzZTx7bWVzc2FnZTogc3RyaW5nOyB1c2VyOiB7dXNlcm5hbWU6IHN0cmluZzsgZW1haWw6IHN0cmluZ319PiB7XHJcbiAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdhY2Nlc3NfdG9rZW4nKVxyXG5cclxuICAgIGlmICghdG9rZW4pIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFjY2VzcyB0b2tlbiBmb3VuZCcpXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfVVJMfS9hcGkvdjEvYXV0aC9tZWAsIHtcclxuICAgICAgICBtZXRob2Q6ICdQQVRDSCcsXHJcbiAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0b2tlbn1gXHJcbiAgICAgICAgfSxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKVxyXG4gICAgfSlcclxuXHJcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSBhd2FpdCByZXNwb25zZS5qc29uKClcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IuZGV0YWlsIHx8ICdGYWlsZWQgdG8gdXBkYXRlIHByb2ZpbGUnKVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXNwb25zZS5qc29uKClcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNoYW5nZVBhc3N3b3JkKGN1cnJlbnRQYXNzd29yZDogc3RyaW5nLCBuZXdQYXNzd29yZDogc3RyaW5nKTogUHJvbWlzZTx7bWVzc2FnZTogc3RyaW5nfT4ge1xyXG4gICAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnYWNjZXNzX3Rva2VuJylcclxuICAgIGlmICghdG9rZW4pIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFjY2VzcyB0b2tlbiBmb3VuZCcpXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfVVJMfS9hcGkvdjEvYXV0aC9jaGFuZ2UtcGFzc3dvcmRgLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0b2tlbn1gXHJcbiAgICAgICAgfSxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgICAgIGN1cnJlbnRfcGFzc3dvcmQ6IGN1cnJlbnRQYXNzd29yZCxcclxuICAgICAgICAgICAgbmV3X3Bhc3N3b3JkOiBuZXdQYXNzd29yZFxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcbiAgICApXHJcblxyXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgIGNvbnN0IGVycm9yID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yLmRldGFpbCB8fCAnRmFpbGVkIHRvIGNoYW5nZSBwYXNzd29yZCcpXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlV2Vla2x5R29hbCh3ZWVrbHlHb2FsSG91cnM6IG51bWJlcik6IFByb21pc2U8e21lc3NhZ2U6IHN0cmluZzsgd2Vla2x5X2dvYWxfaG91cnM6IG51bWJlcjsgbmV4dF91cGRhdGVfYXZhaWxhYmxlOiBzdHJpbmd9PiB7XHJcbiAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdhY2Nlc3NfdG9rZW4nKVxyXG5cclxuICAgIGlmICghdG9rZW4pIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFjY2VzcyB0b2tlbiBmb3VuZCcpXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfVVJMfS9hcGkvdjEvYXV0aC9nb2FsYCwge1xyXG4gICAgICAgIG1ldGhvZDogJ1BBVENIJyxcclxuICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3Rva2VufWBcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHt3ZWVrbHlfZ29hbF9ob3Vyczogd2Vla2x5R29hbEhvdXJzfSlcclxuICAgIH0pXHJcblxyXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgIGNvbnN0IGVycm9yID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yLmRldGFpbCB8fCAnRmFpbGVkIHRvIHVwZGF0ZSB3ZWVrbHkgZ29hbCcpXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxyXG59Il0sIm5hbWVzIjpbIkFQSV9VUkwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX1VSTCIsInJlZ2lzdGVyVXNlciIsImRhdGEiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5Iiwib2siLCJlcnJvciIsImpzb24iLCJFcnJvciIsImRldGFpbCIsImxvZ2luVXNlciIsImZvcm1EYXRhIiwiVVJMU2VhcmNoUGFyYW1zIiwiYXBwZW5kIiwiZW1haWwiLCJwYXNzd29yZCIsImdldEN1cnJlbnRVc2VyIiwidG9rZW4iLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiY3JlYXRlQ29udmVyc2F0aW9uIiwiZ2V0Q29udmVyc2F0aW9ucyIsImdldENvbnZlcnNhdGlvbiIsImNvbnZlcnNhdGlvbklkIiwic2VuZE1lc3NhZ2UiLCJzZW5kTWVzc2FnZVN0cmVhbSIsIm9uQ2h1bmsiLCJvbkNvbXBsZXRlIiwib25FcnJvciIsInNpZ25hbCIsInJlYWRlciIsImdldFJlYWRlciIsImRlY29kZXIiLCJUZXh0RGVjb2RlciIsIm1lc3NhZ2VJZCIsImRvbmUiLCJ2YWx1ZSIsInJlYWQiLCJjaHVuayIsImRlY29kZSIsInN0cmVhbSIsImxpbmVzIiwic3BsaXQiLCJsaW5lIiwic3RhcnRzV2l0aCIsInNsaWNlIiwicGFyc2VkIiwicGFyc2UiLCJtZXNzYWdlX2lkIiwiY29udGVudCIsImUiLCJjb25zb2xlIiwibmFtZSIsImxvZyIsImVycm9yTWVzc2FnZSIsIm1lc3NhZ2UiLCJnZW5lcmF0ZUNvbnZlcnNhdGlvblRpdGxlIiwiZGVsZXRlQ29udmVyc2F0aW9uIiwiZGVsZXRlTWVzc2FnZSIsImdldFByb2dyZXNzU3RhdHMiLCJnZXRQcm9ncmVzc0FjdGl2aXR5IiwidXBkYXRlVXNlclByb2ZpbGUiLCJjaGFuZ2VQYXNzd29yZCIsImN1cnJlbnRQYXNzd29yZCIsIm5ld1Bhc3N3b3JkIiwiY3VycmVudF9wYXNzd29yZCIsIm5ld19wYXNzd29yZCIsInVwZGF0ZVdlZWtseUdvYWwiLCJ3ZWVrbHlHb2FsSG91cnMiLCJ3ZWVrbHlfZ29hbF9ob3VycyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/api.ts\n"));

/***/ })

});